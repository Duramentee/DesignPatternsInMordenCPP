//
// Created by lsx31 on 25-2-12.
//

/*
    总结
	建造者模式的目标是定义一个完全用于分段构造复杂对象或一组对象的组件。

	我们已经观察到建造者的以下关键特征：
	建造者可以拥有流畅的接口，可用于使用单个调用链进行复杂的构造。
	为了支持这个，构造函数应该返回this或*this。
	为了强制API的用户使用一个构造器，
	我们可以使目标对象的构造器不可访问，然后定义一个静态的create()函数来返回这个构造器。
	通过定义适当的操作符，可以将构造器强制转换为对象本身。
	多亏了统一的初始化器语法，groovy风格的建造者在c++中是可能的。
	这种方法非常普遍，并且允许创建不同的领域特定语言(DSLs)。
	单个建造者接口可以公开多个子建造者。
	通过巧妙地使用继承和流畅接口，可以轻松地从一个建造者跳转到另一个。
	重申一下我已经提到过的内容，
	当对象的构造是一个重要的过程时，使用建造者模式是有意义的。
	由有限数量的合理命名的构造函数参数明确构造的简单对象可能应该使用构造函数(或依赖注入)，
	而不需要这样的建造者。
*/

// 方便起见, main 函数在各个 cpp 文件中给出实现, 单独调用

// int main() {
// 	return 0;
// }
