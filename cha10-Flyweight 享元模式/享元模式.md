# 享元模式

## 享元模式

今天读第11种设计模式享元模式.

享元(有时也称为token或cookie)是一种临时组件，可以看作是对某个对象的智能引用。

通常，享元模式的核心应用场景是 **优化大量相似对象的内存占用和性能开销**.

下面是一些相关场景:

### 用户名

现在我们有一个大型在线游戏, 里面有很多同名角色, 比如一个叫 `爱猫TV之圆头耄耋来给你踩背` 的用户. 如果我们为每个这样的名字都存储一份, 那么会带来很大的空间浪费(可能是14个字节?), 因此, 我们可以只存储一次名称, 然后再存一个指向该名称的每个用户的指针(占用8字节), 这样一来就能省下不少空间了.

不过我们也可以使用索引来表示一个用户名, 我们这样定义:

```cpp
#include <cstdint>

typedef uint32_t key;
```

基于这个型别, 我们可以这样定义用户:

```cpp
#include <cstdint>
#include <string>
#include <boost/bimap.hpp>

typedef uint32_t key;

using namespace std;

struct User {
protected:
	key first_name_;
	key last_name_;
	
	static bimap<key, string> names_;
	static key seed_;
	
	static key add(const string& s);

public:
	User(const string& first_name, const string& last_name) :
		first_name_{add(first_name)}, last_name_{add(last_name)} {}
};
```

这里的 `bimap` 即 `boost::map` 是 `boost` 库中的双向映射容器. `bimap` 能够更容易地搜索到副本, 如果姓或者名已经在 `bimap` 中了, 那么我们只是返回它的索引.

然后是构造函数, 构造函数利用 `add()` 函数的返回值初始化成员 `first_name_` 和 成员 `last_name_`.

然后是 `add()` 函数的实现:

```cpp
key User::add(const string& s) {
	auto it = names_.right.find(s);
	if (it == names_.right.end()) {
		names_.insert( {++seed_, s} );
		return seed_;
	}

	return it->second;
}
```

这是 `get-or-add` 机制的标准执行.

如果想把姓和名暴露给外部, 我们需要提供适当的 `getter` 和 `setter`, 如果为了方便地输出信息可以重载运算符 `<<`, 如下是完整代码:

```cpp
#include <cstdint>
#include <string>
#include <iostream>
#include <boost/bimap.hpp>

using key = uint32_t;

using namespace std;

struct User {
protected:
	key first_name_;
	key last_name_;

	static bimap<key, string> names_;
	static key seed_;

	static key User::add(const string& s) {
		auto it = names_.right.find(s);
		if (it == names_.right.end()) {
			names_.insert( {++seed_, s} );
			return seed_;
		}

		return it->second;
	}

public:
	User(const string& first_name, const string& last_name) :
		first_name_{add(first_name)}, last_name_{add(last_name)} {}

	[[nodiscard]] const string& get_first_name() const {
		return names_.left.find(first_name_)->second;
	}
	[[nodiscard]] const string& get_last_name() const {
		return names_.left.find(last_name_)->second;
	}

	friend ostream& operator<<(ostream& os, const User& obj)
	{
		return os << "first_name: " << obj.get_first_name()
				  << " last_name: " << obj.get_last_name();
	}
};
```

这样就完成了, 相比较于为每一个人的用户名都给出一个存储, 这样可以节省内存, 而且我们这里的 `key` 是 `uint32_t` 类型, 如果实际情况更小一些或者更大一些自然就可以额外调整了.



### Boost.Flyweight

在前面的示例中，我们动手实现了一个享元，其实我们可以直接使用Boost库中提供的`boost::flyweight`，这使得`User`类的实现变得非常简单。

```cpp
struct User2 {
	flyweight<string> first_name, last_name;

	User2(const string& first_name, const string& last_name) :
		first_name{first_name},
		last_name{last_name} {}
};
```

可以通过运行以下代码来验证它实际上是享元:

```cpp
void test() {
	User2 john_doe{"John", "Doe"};
	User2 jane_doe{"Jane", "Doe"};
	cout << boolalpha <<
		(&jane_doe.last_name.get() == &john_doe.last_name.get());
	// true
}
```



### String Ranges















































